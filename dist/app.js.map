{"version":3,"file":"app.js","mappings":";;;;;;;;;;;;;;;AAAa;;AAEb,YAAY,SAAS;AACrB,YAAY,UAAU;AACa;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,cAAc;AAC3C,+BAA+B,cAAc;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sDAAe;AAC/B;AACA,wCAAwC;AACxC;AACA;;AAEA,gBAAgB,sDAAe;AAC/B,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;;AAEA,4BAA4B;;AAE5B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,WAAW,cAAc,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;;;;ACnYJ;;AAEwB;AACF;AACA;AACA;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,8CAAM;AAC9B;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,mBAAmB;AACvD,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,mBAAmB;AACrD,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,sDAAe;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,sDAAe;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,sDAAe;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;ACroBH;;AAEb,YAAY,SAAS;AACrB,YAAY,UAAU;AACtB,YAAY,QAAQ;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;;;;;ACnCJ;;AAEwB;AACE;AACJ;AACF;AACE;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,4CAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA,wBAAwB,qBAAqB;AAC7C;AACA;;AAEA,wCAAwC,0CAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA,4BAA4B,qBAAqB;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEe;;;;;;;;;;;;;;;;AC1NF;AACb,YAAY,OAAO;AACgB;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,cAAc;AAC3C,+BAA+B,cAAc;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sDAAe;AAC/B;AACA,wCAAwC;AACxC;AACA;;AAEA,gBAAgB,sDAAe;AAC/B,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sDAAe;AAC/B;AACA;;AAEA,gBAAgB,sDAAe;AAC/B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;AChkBL;;AAEsB;AACnC,YAAY,UAAU;AACtB,YAAY,QAAQ;;AAEpB,oBAAoB,4CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,WAAW,cAAc,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;AC9FJ;;AAEb,YAAY,SAAS;AACrB,YAAY,UAAU;AACtB,YAAY,QAAQ;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;;AC3CH;;AAEb,YAAY,SAAS;AACrB,YAAY,UAAU;AACW;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,eAAe;AACnC;AACA,sBAAsB,kBAAkB;AACxC;AACA;;AAEA,sCAAsC,0CAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;AChEN;;AAEb;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEiB;;;;;;;UC1DjB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNa;;AAEoB;AACI;AACN;;AAE/B,eAAe,0CAAI;AACnB,cAAc,wCAAG;;AAEjB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,wDAAwD,iCAAiC;AACzF,sDAAsD,+BAA+B;AACrF;AACA,wDAAwD,qCAAqC;AAC7F,0DAA0D,oCAAoC;AAC9F;AACA,CAAC;;AAED,gCAAgC;AAChC,+BAA+B;;AAE/B;AACA;AACA;AACA;;AAEA;AACA","sources":["webpack://rpg-game/./assets/js/Enemy.js","webpack://rpg-game/./assets/js/Game.js","webpack://rpg-game/./assets/js/Layer.js","webpack://rpg-game/./assets/js/Map.js","webpack://rpg-game/./assets/js/Player.js","webpack://rpg-game/./assets/js/Slime.js","webpack://rpg-game/./assets/js/Tile.js","webpack://rpg-game/./assets/js/TileSet.js","webpack://rpg-game/./assets/js/funcs.js","webpack://rpg-game/webpack/bootstrap","webpack://rpg-game/webpack/runtime/define property getters","webpack://rpg-game/webpack/runtime/hasOwnProperty shorthand","webpack://rpg-game/webpack/runtime/make namespace object","webpack://rpg-game/./assets/js/main.js"],"sourcesContent":["\"use strict\";\n\n// import { Player } from './Player.js';\n// import { TileSet } from './TileSet.js';\nimport { funcs } from \"./funcs.js\";\n\nclass Enemy {\n  constructor(x, y, name, maxHealth, damage, speed, expGive) {\n    this.name = name;\n    this.maxHealth = maxHealth;\n    this.health = maxHealth;\n    this.damage = damage;\n    this.speed = speed;\n    this.expGive = expGive;\n    this.xPos = x;\n    this.yPos = y;\n    // this.image = 'slime_red.png';\n    this.offsetFrameY = 0;\n    this.offsetFrameX = 0;\n    this.animationFrames = [3];\n    this.width = 16;\n    this.height = 16;\n    this.hurtTimer = null;\n    this.alive = true;\n    this.hurt = false;\n    this.missiles = [];\n    this.attacking = false;\n    this.attackCooldown = 2000;\n    this.moveTimer = null;\n    this.canMove = true;\n    this.isCollidingX = false;\n    this.isCollidingY = false;\n  }\n\n  getImage() {\n    return this.image;\n  }\n\n  getWidth() {\n    return this.width;\n  }\n\n  getHeight() {\n    return this.height;\n  }\n\n  calculateAttackCooldown() {\n    return this.attackCooldown;\n  }\n\n  move(player, map) {\n    let dx = player.posX - this.getXPos();\n    let dy = player.posY - this.getYPos();\n    let distance = Math.round(Math.sqrt(dx * dx + dy * dy));\n\n    if (distance < 300 && distance > 150) {\n      if (!this.hurt) {\n        this.doMove(distance, dx, dy, map);\n      }\n    } else if (distance > 300) {\n      this.moveRandom();\n    }\n  }\n\n  checkObjectsCollision(a1, a2, map) {\n    let objL = map.plane.objects;\n    let ts = map.tileSets[0].tiles;\n\n    // console.log(map);\n    for (let x = map.startX; x < map.endX; x++) {\n      for (let y = map.startY; y < map.endY; y++) {\n        if (objL[x][y]) {\n          let tileType = objL[x][y].getType();\n\n          if (tileType != 0) {\n            let t = {\n              x: objL[x][y].xOffset + map.worldXOffset,\n              y: objL[x][y].yOffset + map.worldYOffset,\n              width: objL[x][y].width,\n              height: objL[x][y].height\n            };\n\n            if (funcs.isCollide(a1, t)) {\n              // console.log(objL[x][y])\n              // console.log('colliding;')\n              this.isCollidingX = true;\n            }\n\n            if (funcs.isCollide(a2, t)) {\n              // console.log('colliding;')\n              this.isCollidingY = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  doMove(distance, dx, dy, map) {\n    if (distance > this.moveSpeed) {\n      clearInterval(this.moveTimer);\n      let hMovement = dx > 0 ? 1 : dx < 0 ? -1 : 0;\n      let vMovement = dy > 0 ? 1 : dy < 0 ? -1 : 0;\n      let xSpeed = Math.round((dx / distance) * this.moveSpeed * hMovement);\n      let ySpeed = Math.round((dy / distance) * this.moveSpeed * vMovement);\n\n      let a1 = {\n        x: this.getXPos() + map.worldXOffset + this.moveSpeed * hMovement,\n        y: this.getYPos() + map.worldYOffset,\n        width: this.width * 2,\n        height: this.height * 2\n      };\n      let a2 = {\n        x: this.getXPos() + map.worldXOffset,\n        y: this.getYPos() + map.worldYOffset + this.moveSpeed * vMovement,\n        width: this.width * 2,\n        height: this.height * 2\n      };\n\n      this.checkObjectsCollision(a1, a2, map);\n\n      // if (this.isCollidingX && this.isCollidingY) {\n      //     // this.stopMoving();\n      // } else {\n      if (!this.isCollidingX) {\n        this.xPos += xSpeed * hMovement;\n        // this.posX += xSpeed * hMovement;\n      } else if (ySpeed <= 0.5) {\n        // this.stopMoving();\n        // this.posY += this.moveSpeed * vMovement;\n        // this.posX += 0.1 * -hMovement;\n      }\n      if (!this.isCollidingY) {\n        this.yPos += ySpeed * vMovement;\n        // this.posY += ySpeed * vMovement;\n      } else if (xSpeed <= 0.5) {\n        // this.stopMoving();\n        // this.posX += this.moveSpeed * hMovement;\n        // this.posY += 0.1 * -vMovement;\n      }\n      // }\n\n      this.moving = true;\n    } else {\n      this.moving = false;\n    }\n  }\n\n  moveRandom() {\n    let canMove = this.canMove;\n\n    if (canMove) {\n      let r = Math.random();\n      let plusOrMinus = r < 0.33 ? -1 : r > 0.66 ? 1 : 0;\n      let targetX = this.getXPos() + 100 * plusOrMinus;\n\n      r = Math.random();\n      plusOrMinus = r < 0.33 ? -1 : r > 0.66 ? 1 : 0;\n      let targetY = this.getYPos() + 100 * plusOrMinus;\n      let moveLoop = this.moveLoop.bind(this);\n      let moveTimer = this.moveTimer;\n      let setCanMove = this.setCanMove.bind(this);\n      let target = {\n        targetX: targetX,\n        targetY: targetY,\n        posX: this.getXPos(),\n        posY: this.getYPos()\n      };\n\n      this.canMove = false;\n      this.moveTimeout = setTimeout(function() {\n        clearInterval(moveTimer);\n        setCanMove();\n      }, 5000);\n\n      this.moveTimer = setInterval(function() {\n        moveLoop(target);\n      }, 50);\n    }\n  }\n\n  setCanMove() {\n    this.canMove = true;\n  }\n\n  moveLoop(target) {\n    let dx = target.targetX - this.xPos;\n    let dy = target.targetY - this.yPos;\n    let hMovement = dx > 0 ? 1 : dx < 0 ? -1 : 0;\n    let vMovement = dy > 0 ? 1 : dy < 0 ? -1 : 0;\n    let distance = Math.sqrt(dx * dx + dy * dy);\n    let xSpeed = (dx / distance) * this.moveSpeed * hMovement;\n    let ySpeed = (dy / distance) * this.moveSpeed * vMovement;\n\n    if (distance <= this.moveSpeed) {\n      clearInterval(this.moveTimer);\n    } else if (distance > this.moveSpeed) {\n      this.xPos += xSpeed * hMovement;\n      this.yPos += ySpeed * vMovement;\n    }\n  }\n\n  setAttacking() {\n    this.attacking = true;\n  }\n\n  setNotAttacking() {\n    this.attacking = false;\n  }\n\n  checkAttack(player) {\n    if (!this.attacking && player.alive && !this.hurt) {\n      let dx = player.posX - this.getXPos();\n      let dy = player.posY - this.getYPos();\n      let distance = Math.round(Math.sqrt(dx * dx + dy * dy));\n      let setNotAttacking = this.setNotAttacking.bind(this);\n\n      if (distance < 160) {\n        this.doAttack(player, dy, dx);\n        this.attackTimeout = setTimeout(function() {\n          setNotAttacking();\n        }, this.calculateAttackCooldown());\n        this.attacking = true;\n      }\n    }\n  }\n\n  getMissileImage(dy, dx) {\n    let image = \"enemies/slime_red_missile\";\n    let theta = Math.atan2(dy, dx); // range (-PI, PI]\n    let range = 22.5;\n\n    theta *= 180 / Math.PI; // rads to degs, range (-180, 180]\n\n    if (theta <= 0 + range && theta > 0 - range) {\n      // east\n      image += \"_east\";\n    } else if (theta <= 45 + range && theta > 45 - range) {\n      // south-east\n      image += \"_south_east\";\n    } else if (theta <= 90 + range && theta > 90 - range) {\n      // south\n      image += \"_south\";\n    } else if (theta <= 135 + range && theta > 135 - range) {\n      // south-west\n      image += \"_south_west\";\n    } else if (\n      (theta <= 180 && theta > 180 - range) ||\n      (theta <= -180 + range && theta > -180)\n    ) {\n      // west\n      image += \"_west\";\n    } else if (theta <= -135 + range && theta > -135 - range) {\n      // south-west\n      image += \"_north_west\";\n    } else if (theta <= -90 + range && theta > -90 - range) {\n      // south-west\n      image += \"_north\";\n    } else if (theta <= -45 + range && theta > -45 - range) {\n      // south-west\n      image += \"_north_east\";\n    } else {\n      image += \"_east\";\n    }\n\n    image += \".png\";\n    return image;\n  }\n\n  doAttack(player, dy, dx) {\n    let missile = {\n      targetX: player.posX + dx - 16,\n      targetY: player.posY + dy - 16,\n      posX: this.getXPos() - 12,\n      posY: this.getYPos() - 16,\n      moveSpeed: 15,\n      width: 16,\n      height: 16,\n      image: this.getMissileImage(dy, dx),\n      hit: false\n    };\n    let attackLoop = this.attackLoop.bind(this);\n    let missileId = this.missiles.push(missile);\n\n    missile.id = missileId;\n    let attackTimer = setInterval(function() {\n      attackLoop(missile, attackTimer);\n    }, 100);\n  }\n\n  attackLoop(missile, timer) {\n    let dx = missile.targetX - missile.posX;\n    let dy = missile.targetY - missile.posY;\n    let hMovement = dx > 0 ? 1 : dx < 0 ? -1 : 0;\n    let vMovement = dy > 0 ? 1 : dy < 0 ? -1 : 0;\n\n    let distance = Math.sqrt(dx * dx + dy * dy);\n\n    let xSpeed = (dx / distance) * missile.moveSpeed * hMovement;\n    let ySpeed = (dy / distance) * missile.moveSpeed * vMovement;\n\n    if (distance <= missile.moveSpeed || missile.hit) {\n      for (let m in this.missiles) {\n        if (this.missiles[m].id == missile.id) {\n          this.missiles.splice(m, 1);\n          clearInterval(timer);\n        }\n      }\n    } else if (distance > missile.moveSpeed) {\n      missile.posX += xSpeed * hMovement;\n      missile.posY += ySpeed * vMovement;\n    }\n  }\n\n  getXPos() {\n    return this.xPos;\n  }\n\n  getYPos() {\n    return this.yPos;\n  }\n\n  getXCenterPos() {\n    return this.xPos + (this.width * 2) / 2;\n  }\n\n  getYCenterPos() {\n    return this.yPos + (this.height * 2) / 2;\n  }\n\n  startAnimation() {\n    let that = this;\n\n    if (!that.started) {\n      that.animationTimer = setInterval(function() {\n        that.updateAnimationFrames();\n      }, 1000 / 10);\n      that.started = true;\n    }\n  }\n\n  die() {\n    this.alive = false;\n  }\n\n  getHurt(damage) {\n    let that = this;\n\n    if (!that.hurt) {\n      console.log(`${that.name} was damaged ${damage} points!`);\n      that.hurt = true;\n      that.health -= damage;\n      that.hurtTimer = setTimeout(function() {\n        if (that.health <= 0) {\n          that.die();\n          console.log(`${that.name} died!`);\n        }\n        that.hurt = false;\n        console.log(\"not hurt\");\n      }, 200);\n    }\n  }\n\n  updateAnimationFrames() {\n    let that = this;\n    let outOfBounds =\n      that.offsetFrameX >= that.animationFrames[that.offsetFrameY];\n\n    // if (that.attacking && outOfBounds) {\n    //     that.attacking = false;\n    // }\n\n    if (that.hurt && that.offsetFrameX % 2 != 0) {\n      that.offsetFrameY = 1;\n    } else {\n      that.offsetFrameY = 0;\n    }\n\n    if (that.animationFrames[that.offsetFrameY] === undefined || outOfBounds) {\n      that.animationFrame = 0;\n      that.offsetFrameX = 0;\n    } else {\n      that.offsetFrameX += 1;\n    }\n  }\n}\n\nexport { Enemy };\n","\"use strict\";\n\nimport { Player } from \"./Player.js\";\nimport { Enemy } from \"./Enemy.js\";\nimport { Slime } from \"./Slime.js\";\nimport { funcs } from \"./funcs.js\";\n\nclass Game {\n  constructor(width, height) {\n    this.barWidth = 200;\n    this.barHeight = 10;\n    this.started = false;\n    this.plane = [];\n    this.player = null;\n    this.image = null;\n    this.imageUrls = [\n      \"adventurer/adventurer.png\",\n      \"enemies/slime_red.png\",\n      \"cross.png\",\n      \"glove.png\",\n      \"sword.png\",\n      \"enemies/slime_red_missile_east.png\",\n      \"enemies/slime_red_missile_south_east.png\",\n      \"enemies/slime_red_missile_south.png\",\n      \"enemies/slime_red_missile_south_west.png\",\n      \"enemies/slime_red_missile_west.png\",\n      \"enemies/slime_red_missile_north_west.png\",\n      \"enemies/slime_red_missile_north.png\",\n      \"enemies/slime_red_missile_north_east.png\"\n    ];\n    this.images = {};\n    this.enemies = [];\n    this.directions = [\n      \"standingnorth\",\n      \"standingwest\",\n      \"standingeast\",\n      \"standingsouth\",\n      \"runningeast1\",\n      \"runningeast2\"\n    ];\n    this.width = width;\n    this.height = height;\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.id = \"CursorLayer\";\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.canvas.style.zIndex = 8;\n    this.canvas.style.margin = \"auto\";\n    this.canvas.style.display = \"block\";\n    this.canvas.style.border = \"1px solid #bbb\";\n    this.fps = 20;\n    this.timer = null;\n    this.map = null;\n    this.mouseX;\n    this.mouseY;\n  }\n\n  init() {\n    if (this.map.layers.ground) {\n      let startPoint = this.map.dataLayer.startingPoint;\n      let mouseMove = this.mouseMove.bind(this);\n\n      this.imageUrls.push(\n        \"map/\" + this.map.tileSets[0].mapImage.getAttribute(\"source\")\n      );\n      this.map.realWidth = this.map.width * this.map.layers.ground.tileWidth;\n      this.map.realHeight = this.map.height * this.map.layers.ground.tileHeight;\n\n      this.stop();\n      this.player = new Player(startPoint.x, startPoint.y);\n      this.enemies.push(\n        new Slime(\n          startPoint.x + 200,\n          startPoint.y + 200,\n          \"redSlime\",\n          20,\n          10,\n          1,\n          100\n        )\n      );\n      // this.enemies.push(new Slime(\n      //     startPoint.x + 300,\n      //     startPoint.y + 300,\n      //     'redSlime',\n      //     20,\n      //     10,\n      //     1,\n      //     10)\n      // );\n      this.centerCamera();\n\n      let player = this.player;\n      let map = this.map;\n\n      window.addEventListener(\"mousedown\", function(e) {\n        player.mouseDown(e, map.worldXOffset, map.worldYOffset);\n      });\n      window.addEventListener(\"mouseup\", function(e) {\n        player.mouseUp(e, true);\n      });\n      window.addEventListener(\"mousemove\", function(e) {\n        mouseMove(e, true);\n      });\n\n      document.getElementById(\"plane\").appendChild(this.canvas);\n      this.ctx = this.canvas.getContext(\"2d\");\n\n      let loadImage = this.loadImage.bind(this);\n\n      loadImage();\n      // this.loadImage();\n    } else {\n      console.log(\"No ground layer found\");\n    }\n  }\n\n  mouseMove(e) {\n    let el = e.target;\n\n    if ((el.getTagName = \"canvas\")) {\n      this.mouseX = e.clientX - el.offsetLeft;\n      this.mouseY = e.clientY - el.offsetTop;\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      clearInterval(this.timer);\n      this.started = false;\n    }\n  }\n\n  start() {\n    let redraw = this.redraw.bind(this);\n    let startAnimation = this.player.startAnimation.bind(this.player);\n    let startData = this.player.startData.bind(this.player);\n\n    startData();\n    startAnimation();\n    for (let enemy of this.enemies) {\n      enemy.startAnimation();\n    }\n\n    if (!this.started) {\n      this.timer = setInterval(function() {\n        redraw();\n        // }, 1500);\n      }, 1000 / this.fps);\n      this.started = true;\n    }\n  }\n\n  redraw() {\n    this.getMapScope();\n    this.player.move2(\n      {\n        x: this.map.worldXOffset,\n        y: this.map.worldYOffset,\n        w: this.map.realWidth,\n        h: this.map.realHeight\n      },\n      this.enemies,\n      this.map\n    );\n    this.checkEnemies();\n    this.mapScroll();\n    this.draw();\n  }\n\n  checkEnemies() {\n    for (let enemy in this.enemies) {\n      this.enemies[enemy].realXPos =\n        this.enemies[enemy].getXPos() - 16 + this.map.worldXOffset;\n      this.enemies[enemy].realYPos =\n        this.enemies[enemy].getYPos() - 16 + this.map.worldYOffset;\n      this.enemies[enemy].realXCenterPos =\n        this.enemies[enemy].getXCenterPos() + this.map.worldXOffset;\n      this.enemies[enemy].realYCenterPos =\n        this.enemies[enemy].getYCenterPos() + this.map.worldYOffset;\n      if (!this.enemies[enemy].alive) {\n        this.player.getxp(this.enemies[enemy].expGive);\n        this.enemies.splice(enemy, 1);\n      } else {\n        this.enemies[enemy].move(this.player, this.map);\n        this.enemies[enemy].checkAttack(this.player);\n      }\n    }\n  }\n\n  centerCamera() {\n    this.map.worldXOffset =\n      -this.player.posX + this.width / 2 - this.player.height;\n    this.map.worldYOffset =\n      -this.player.posY + this.height / 2 - this.player.height;\n  }\n\n  mapScroll() {\n    let margin = 300;\n    let realYPos = this.player.posY + this.map.worldYOffset;\n    let realXPos = this.player.posX + this.map.worldXOffset;\n    let isBelow = realYPos > this.height - margin ? 1 : 0;\n    let isAbove = realYPos + this.player.height * 2 < margin ? 1 : 0;\n    let isRight =\n      realXPos + this.player.width * 2 > this.width - margin ? 1 : 0;\n    let isLeft = realXPos < margin ? 1 : 0;\n    let dx = this.player.realClickX - this.player.posX;\n    let dy = this.player.realClickY - this.player.posY;\n    let hMovement = dx > 0 ? 1 : dx < 0 ? -1 : 0;\n    let vMovement = dy > 0 ? 1 : dy < 0 ? -1 : 0;\n    let distance = Math.sqrt(dx * dx + dy * dy);\n    let xSpeed = (dx / distance) * this.player.moveSpeed * hMovement;\n    let ySpeed = (dy / distance) * this.player.moveSpeed * vMovement;\n\n    if (\n      isRight &&\n      this.map.worldXOffset - xSpeed * 1 > -this.map.realWidth + this.width\n    ) {\n      this.map.worldXOffset -= xSpeed * 1;\n    } else if (isLeft && this.map.worldXOffset + xSpeed * 1 <= 0) {\n      this.map.worldXOffset += xSpeed * 1;\n    }\n\n    if (\n      isBelow &&\n      this.map.worldYOffset - ySpeed * 1 > -this.map.realHeight + this.height\n    ) {\n      this.map.worldYOffset -= ySpeed * 1;\n    } else if (isAbove && this.map.worldYOffset + ySpeed * 1 < 0) {\n      this.map.worldYOffset += ySpeed * 1;\n    }\n  }\n\n  loadImage() {\n    let imageUrls = this.imageUrls;\n    let start = this.start.bind(this);\n    let loadCounter = 0;\n\n    for (let image of imageUrls) {\n      this.images[image] = new Image();\n      this.images[image].onload = function() {\n        loadCounter++;\n        if (loadCounter === imageUrls.length) {\n          start();\n        }\n      };\n      this.images[image].src = \"assets/img/\" + image;\n    }\n  }\n\n  reset() {\n    this.player.posX = this.player.startX;\n    this.player.posY = this.player.startY;\n  }\n\n  draw() {\n    let getAnimationType = this.player.getAnimationType.bind(this.player);\n\n    // getAnimationType();\n\n    this.ctx.font = \"14px courier\";\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.ctx.msImageSmoothingEnabled = false;\n    this.ctx.webkitImageSmoothingEnabled = false;\n    this.ctx.imageSmoothingEnabled = false;\n\n    this.drawMap();\n    this.drawPlayer();\n    this.drawEnemies();\n    this.drawOverlayObjects();\n    // this.drawAttackingSquares();\n    // this.drawStatusText();\n    this.drawHealthbar();\n    this.drawPointer();\n  }\n\n  getMapScope() {\n    let tileWidth = this.map.tileWidth;\n    let restY = -this.map.worldXOffset % tileWidth;\n\n    let startY = (-this.map.worldXOffset - restY) / tileWidth;\n    let restX = -this.map.worldYOffset % tileWidth;\n\n    let startX = (-this.map.worldYOffset - restX) / tileWidth;\n    let restEndX = (-this.map.worldYOffset + this.width) % tileWidth;\n    let endX = (-this.map.worldYOffset + this.width - restEndX) / tileWidth;\n    let restEndY = (-this.map.worldXOffset + this.width) % tileWidth;\n    let endY = (-this.map.worldXOffset + this.width - restEndY) / tileWidth;\n\n    this.map.startX = startX > 0 ? startX - 1 : 0;\n    this.map.startY = startY > 0 ? startY - 1 : 0;\n\n    this.map.endX = endX + 1 < this.map.width ? endX + 1 : this.map.width;\n    this.map.endY = endY + 1 < this.map.height ? endY + 1 : this.map.height;\n  }\n\n  drawMap() {\n    for (let layer in this.map.plane) {\n      for (let x = this.map.startX; x < this.map.endX; x++) {\n        for (let y = this.map.startY; y < this.map.endY; y++) {\n          if (\n            this.map.plane[layer][x][y] &&\n            this.map.tileSets[0].tiles[this.map.plane[layer][x][y].getType()]\n          ) {\n            let tileType = this.map.plane[layer][x][y].getType();\n\n            this.ctx.drawImage(\n              this.images[\"map/overworld1.png\"], //bilden\n              this.map.tileSets[0].tiles[tileType].xOffset,\n              this.map.tileSets[0].tiles[tileType].yOffset,\n              this.map.tileSets[0].tiles[tileType].getWidth(),\n              this.map.tileSets[0].tiles[tileType].getHeight(),\n              this.map.plane[layer][x][y].xOffset + this.map.worldXOffset,\n              this.map.plane[layer][x][y].yOffset + this.map.worldYOffset,\n              this.map.plane[layer][x][y].getWidth(),\n              this.map.plane[layer][x][y].getHeight()\n            );\n          }\n        }\n      }\n    }\n  }\n\n  drawOverlayObjects() {\n    for (let x = this.map.startX; x < this.map.endX; x++) {\n      for (let y = this.map.startY; y < this.map.endY; y++) {\n        if (\n          this.map.objectsOverlay[x][y] &&\n          this.map.tileSets[0].tiles[this.map.objectsOverlay[x][y].getType()]\n        ) {\n          let tileType = this.map.objectsOverlay[x][y].getType();\n\n          this.ctx.drawImage(\n            this.images[\"map/overworld1.png\"], //bilden\n            this.map.tileSets[0].tiles[tileType].xOffset,\n            this.map.tileSets[0].tiles[tileType].yOffset,\n            this.map.tileSets[0].tiles[tileType].getWidth(),\n            this.map.tileSets[0].tiles[tileType].getHeight(),\n            this.map.objectsOverlay[x][y].xOffset + this.map.worldXOffset,\n            this.map.objectsOverlay[x][y].yOffset + this.map.worldYOffset,\n            this.map.objectsOverlay[x][y].getWidth(),\n            this.map.objectsOverlay[x][y].getHeight()\n          );\n        }\n      }\n    }\n  }\n\n  drawPlayer() {\n    // let facingPlayerOffset = this.player.facingX == 1 ? 10 : 18;\n    let playerYPos = this.player.posY + 18 + this.map.worldYOffset - 32;\n    let playerXPos = this.player.posX + 14 + this.map.worldXOffset - 32;\n    // let targetX = this.player.realClickX + this.map.worldXOffset - 16;\n    // let targetY = this.player.realClickY + this.map.worldYOffset - 16;\n\n    // this.player.facingPlayerOffset = facingPlayerOffset;\n    this.player.playerXPos = playerXPos;\n    this.player.playerYPos = playerYPos;\n\n    // if (this.player.clickTarget) {\n    //     targetX = this.player.clickTarget.getXPos() + this.map.worldXOffset - 16;\n    //     targetY = this.player.clickTarget.getYPos() + this.map.worldYOffset - 16;\n    // }\n\n    // if (this.player.realClickX && this.player.realClickX) {\n    //     this.ctx.drawImage(\n    //         this.images['cross.png'],\n    //         targetX,\n    //         targetY,\n    //         32,\n    //         32\n    //     );\n    // }\n\n    // this.ctx.fillStyle = '#BBBBBB4D';\n    // this.ctx.fillRect(\n    //     this.player.playerXPos,\n    //     this.player.playerYPos,\n    //     (this.player.width * 1.5) - 12,\n    //     (this.player.height * 1.5) - 6\n    // );\n\n    this.ctx.drawImage(\n      this.images[\"adventurer/adventurer.png\"],\n      this.player.offsetFrameX * this.player.width, // sidled/animation\n      this.player.offsetFrameY * this.player.height + 1, // höjden\n      this.player.width,\n      this.player.height,\n      this.player.posX + this.map.worldXOffset - 32,\n      this.player.posY + this.map.worldYOffset - 32,\n      // playerXPos,\n      // playerYPos,\n      // this.player.posX + this.map.worldXOffset,\n      // this.player.posY + this.map.worldYOffset,\n      this.player.width * 2,\n      this.player.height * 2\n    );\n    // this.ctx.fillStyle = '#000000';\n    // this.ctx.fillRect(\n    //     this.player.posX + this.map.worldXOffset,\n    //     this.player.posY + this.map.worldYOffset,\n    //     1,\n    //     1\n    // );\n  }\n\n  drawEnemies() {\n    let a = {\n      x: this.player.playerXPos,\n      y: this.player.playerYPos,\n      width: this.player.width * 1.5 - 12,\n      height: this.player.height * 1.5 - 6\n    };\n\n    // this.ctx.fillStyle = '#BBBBBB4D';\n    // this.ctx.fillRect(\n    //     this.player.playerXPos,\n    //     this.player.playerYPos,\n    //     (this.player.width * 1.5) - 12,\n    //     (this.player.height * 1.5) - 6\n    // );\n\n    for (let enemy of this.enemies) {\n      this.ctx.drawImage(\n        this.images[\"enemies/\" + enemy.getImage()],\n        enemy.offsetFrameX * enemy.width, // sidled/animation\n        enemy.offsetFrameY * enemy.height, // höjden\n        enemy.getWidth(),\n        enemy.getHeight(),\n        enemy.realXPos,\n        enemy.realYPos,\n        enemy.getWidth() * 2,\n        enemy.getHeight() * 2\n      );\n      this.ctx.fillStyle = \"#000000\";\n      this.ctx.fillRect(\n        enemy.realXPos + (enemy.width * 2) / 2,\n        enemy.realYPos + (enemy.height * 2) / 2,\n        3,\n        3\n        // enemy.getWidth() * 2,\n        // enemy.getHeight() * 2\n      );\n\n      if (enemy.missiles) {\n        for (let missile of enemy.missiles) {\n          this.ctx.drawImage(\n            this.images[missile.image],\n            missile.posX - 8 + this.map.worldXOffset,\n            missile.posY - 8 + this.map.worldYOffset,\n            32,\n            32\n          );\n          // this.ctx.fillRect(\n          //     missile.posX + this.map.worldXOffset,\n          //     missile.posY + this.map.worldYOffset,\n          //     missile.width,\n          //     missile.height\n          // );\n          let b = {\n            x: missile.posX + this.map.worldXOffset,\n            y: missile.posY + this.map.worldYOffset,\n            width: missile.width,\n            height: missile.height\n          };\n\n          if (funcs.isCollide(a, b)) {\n            missile.hit = true;\n            this.player.getHurt(enemy.damage);\n            // enemy.getHurt(this.player.damage);\n          }\n        }\n\n        // for (let enemy of this.enemies) {\n        // }\n      }\n\n      /*if (funcs.isCollide({\n                x: this.player.playerXPos,\n                y: this.player.playerYPos,\n                width: (this.player.width * 1.5) - 12,\n                height: (this.player.height * 1.5) - 6\n            }, {\n                x: enemy.realXPos,\n                y: enemy.realYPos,\n                width: enemy.getWidth() * 2,\n                height: enemy.getHeight() * 2\n            }) && !enemy.hurt) {\n            // if (realXPos > attackXPos &&\n            //     realXPos < attackXPos + 20 &&\n            //     realYPos > attackYPos &&\n            //     realYPos < attackYPos + 40\n            // ) {\n                this.player.getHurt(enemy.damage);\n            }*/\n    }\n  }\n\n  drawAttackingSquares() {\n    if (this.player.attacking) {\n      let facingOffset = this.player.facingX == 1 ? 32 + 12 : 0;\n      let attackYPos = this.player.posY + 20 + this.map.worldYOffset - 32;\n      let attackXPos =\n        this.player.posX + facingOffset + this.map.worldXOffset - 32;\n\n      let a = {\n        x: attackXPos,\n        y: attackYPos,\n        width: 20,\n        height: 40\n      };\n\n      this.ctx.fillStyle = \"#005AFF4D\";\n      this.ctx.fillRect(attackXPos, attackYPos, 20, 40);\n      this.ctx.fillStyle = \"#005AFF\";\n      this.ctx.strokeRect(attackXPos, attackYPos, 20, 40);\n\n      for (let enemy of this.enemies) {\n        let b = {\n          x: enemy.realXPos,\n          y: enemy.realYPos,\n          width: enemy.getWidth() * 2,\n          height: enemy.getHeight() * 2\n        };\n\n        if (funcs.isCollide(a, b)) {\n          enemy.getHurt(this.player.damage);\n        }\n      }\n    }\n  }\n\n  drawStatusText() {\n    this.ctx.font = \"20px courier\";\n    this.ctx.fillStyle = \"#fff\";\n    this.ctx.fillText(\n      \"lvl: \" +\n        this.player.level +\n        \"  xp \" +\n        this.player.experience +\n        \"/\" +\n        this.player.nextLevel,\n      20,\n      80\n    );\n    this.ctx.fillStyle = \"#ffffffc\";\n    this.ctx.fillText(this.player.facing, 10, 120);\n    this.ctx.fillText(\n      Math.round(this.player.posY) + \", \" + Math.round(this.player.posX),\n      10,\n      140\n    );\n\n    this.ctx.fillText(\n      Math.round(\n        this.player.posY + this.map.worldYOffset - this.player.height * 2\n      ) +\n        \", \" +\n        Math.round(\n          this.player.posX + this.map.worldXOffset - this.player.width * 2\n        ),\n      10,\n      160\n    );\n\n    this.ctx.fillText(\n      Math.round(this.player.clickY - this.map.worldYOffset) +\n        \", \" +\n        Math.round(this.player.clickX - this.map.worldXOffset),\n      10,\n      180\n    );\n    this.ctx.stroke();\n  }\n\n  drawHealthbar() {\n    this.ctx.font = \"20px courier\";\n    this.ctx.fillStyle = \"#fff\";\n    this.ctx.fillText(\n      \"lvl: \" +\n        this.player.level +\n        \"  xp \" +\n        this.player.experience +\n        \"/\" +\n        this.player.nextLevel,\n      20,\n      80\n    );\n    this.ctx.fillStyle = \"#FFFFFF55\";\n    this.ctx.fillRect(17, 17, this.barWidth + 6, this.barHeight + 6);\n\n    this.ctx.fillStyle = \"#CB2E2E\";\n    this.ctx.fillRect(\n      20,\n      20,\n      this.barWidth * (this.player.health / this.player.maxHealth),\n      this.barHeight\n    );\n\n    this.ctx.fillStyle = \"#FFFFFF55\";\n    this.ctx.fillRect(17, 37, this.barWidth + 6, this.barHeight + 6);\n\n    this.ctx.fillStyle = \"#24A733\";\n    this.ctx.fillRect(\n      20,\n      40,\n      this.barWidth * (this.player.stamina / this.player.maxStamina),\n      this.barHeight\n    );\n  }\n\n  drawPointer() {\n    let image = this.images[\"glove.png\"];\n    this.player.hoverAction = \"move\";\n    this.player.hoverTarget = null;\n\n    let a = {\n      x: this.mouseX,\n      y: this.mouseY,\n      width: 1,\n      height: 1\n    };\n\n    for (let enemy of this.enemies) {\n      let b = {\n        x: enemy.realXPos,\n        y: enemy.realYPos,\n        width: enemy.getWidth() * 2,\n        height: enemy.getHeight() * 2\n      };\n\n      if (funcs.isCollide(a, b)) {\n        this.player.hoverAction = \"attack\";\n        this.player.hoverTarget = enemy;\n        image = this.images[\"sword.png\"];\n      }\n    }\n\n    if (this.mouseX && this.mouseY) {\n      this.ctx.drawImage(image, this.mouseX, this.mouseY, 32, 32);\n    }\n  }\n}\n\nexport { Game };\n","\"use strict\";\n\n// import { Player } from './Player.js';\n// import { TileSet } from './TileSet.js';\n// import { funcs } from './funcs.js';\n\nclass Layer {\n  constructor(\n    id,\n    data,\n    width,\n    height,\n    visible,\n    opacity,\n    layerName,\n    tileWidth,\n    tileHeight,\n    objects\n  ) {\n    this.id = id;\n    this.name = layerName;\n    this.width = width;\n    this.height = height;\n    this.visible = visible;\n    this.opacity = opacity;\n    this.tileWidth = tileWidth;\n    this.tileHeight = tileHeight;\n    this.data = data;\n    this.objects = objects;\n    // console.log(this.image);\n    // var tileAmountWidth = Math.floor(width / tileWidth);\n    // this.lastgid = tileAmountWidth * Math.floor(height / tileHeight) + firstgid - 1;\n  }\n}\n\nexport { Layer };\n","\"use strict\";\n\nimport { Player } from \"./Player.js\";\nimport { TileSet } from \"./TileSet.js\";\nimport { Layer } from \"./Layer.js\";\nimport { Tile } from \"./Tile.js\";\nimport { funcs } from \"./funcs.js\";\n\nclass Map {\n  constructor(url) {\n    this.url = url;\n    this.xmlDoc = null;\n    this.tileSets = [];\n    this.layers = {};\n    this.plane = [];\n    this.data = null;\n    this.worldXOffset = 0;\n    this.worldYOffset = 0;\n    this.realWidth = 0;\n    this.realHeight = 0;\n    this.dataLayer = {};\n  }\n\n  loadLayers() {\n    console.log(this.data);\n    for (let datalayer of this.data.layers) {\n      let id = datalayer.id;\n      let width = datalayer.width;\n      let height = datalayer.height;\n      let visible = datalayer.visible;\n      let opacity = datalayer.opacity;\n      let layerName = datalayer.name.toCamelCase();\n      let tileWidth = this.data.tilewidth;\n      let tiledata = datalayer.data;\n      let tileHeight = this.data.tileheight;\n      let objects = datalayer.objects;\n\n      this.layers[layerName] = new Layer(\n        id,\n        tiledata,\n        width,\n        height,\n        visible,\n        opacity,\n        layerName,\n        tileWidth,\n        tileHeight,\n        objects\n      );\n    }\n  }\n\n  loadTilesets() {\n    // console.log(this.data.tilesets)\n    for (let tileset of this.data.tilesets) {\n      // console.log(tileset);\n      let firstGid = tileset.firstgid;\n      let tilesetImagePath = tileset.image;\n      let width = this.data.width;\n      let height = this.data.height;\n      let tileWidth = this.data.tilewidth;\n      let tileHeight = this.data.tileheight;\n\n      this.tileSets.push(\n        new TileSet(\n          firstGid,\n          tileWidth,\n          tileHeight,\n          tilesetImagePath,\n          width,\n          height\n        )\n      );\n    }\n  }\n\n  setMapData() {\n    if (this.layers[\"dataLayer\"]) {\n      for (let dataObj of this.layers[\"dataLayer\"].objects) {\n        this.dataLayer[dataObj.name.toCamelCase()] = dataObj;\n      }\n      delete this.layers[\"dataLayer\"];\n      // this.layers.splice(dataLayer, 1);\n    }\n  }\n\n  async loadTileSetimages() {\n    for (let tileset of this.tileSets) {\n      await tileset.loadTileSetImage();\n    }\n  }\n\n  async getMapData() {\n    let that = this;\n    let object = await window.fetch(that.url);\n    let data = await object.json();\n\n    that.data = data;\n  }\n\n  async loadMap() {\n    await this.getMapData();\n    let that = this;\n\n    that.width = that.data.width;\n    that.height = that.data.height;\n    that.tileWidth = that.data.tilewidth;\n    that.tileHeight = that.data.tileheight;\n\n    that.loadLayers();\n    that.loadTilesets();\n    await that.loadTileSetimages();\n    that.setMapData();\n    // that.layers[0].data\n    for (let layer in that.layers) {\n      let tileCounter = 0;\n\n      that.plane[layer] = [];\n      for (let y = 0; y < that.data.height; y++) {\n        that.plane[layer][y] = [];\n        for (let x = 0; x < that.data.width; x++) {\n          let xOffset = x * that.data.tilewidth;\n          let yOffset = y * that.data.tileheight;\n\n          that.plane[layer][y][x] = new Tile(\n            tileCounter,\n            xOffset,\n            yOffset,\n            that.data.tilewidth,\n            that.data.tileheight,\n            that.layers[layer].data[tileCounter]\n          );\n          tileCounter++;\n        }\n      }\n    }\n    that.objectsOverlay = that.plane.objectsOverlay;\n    delete that.plane.objectsOverlay;\n    // console.log(that.objectsOverlay);\n    /*for (let y = 0; y < that.data.height; y++) {\n            that.plane[y] = [];\n            for (let x = 0; x < that.data.width; x++) {\n                let xOffset = x * that.data.tilewidth;\n                let yOffset = y * that.data.tileheight;\n\n                that.plane[y][x] = new Tile(\n                    tileCounter,\n                    xOffset,\n                    yOffset,\n                    that.data.tilewidth,\n                    that.data.tileheight,\n                    that.layers['ground'].data[tileCounter]\n                );\n                tileCounter++;\n            }\n        }*/\n    // let screenBitmap = new Bitmap(new BitmapData(mapWidth * tileWidth, mapHeight * tileHeight, false, 0x22ffff));\n    // let screenBitmapTopLayer = new Bitmap(new BitmapData(mapWidth*tileWidth,mapHeight*tileHeight,true,0));\n\n    // load images for tileset\n    // for (let i = 0; i < that.tileSets.length; i++) {\n    //     // let loader = new TileCodeEventLoader();\n    //     // loader.contentLoaderInfo.addEventListener(Event.COMPLETE, tilesLoadComplete);\n    //     // loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, progressHandler);\n    //     // loader.tileSet = tileSets[i];\n    //     // loader.load(new URLRequest(\"../assets/\" + tileSets[i].source));\n    //     // eventLoaders.push(loader);\n    //     let mapimage = await window.fetch('assets/img/map/' + that.tileSets[i].source);\n    //     let text = await mapimage.text();\n    //     let xmlDoc = (new window.DOMParser()).parseFromString(text, \"text/xml\");\n\n    //     console.log(xmlDoc);\n    //     // console.log(xmlDoc.activeElement.children[0]);\n    //     that.mapImage = xmlDoc.activeElement.children[0];\n    // }\n    // let screenBitmap = image\n  }\n\n  /*async loadMap() {\n        let that = this;\n        let xmlDoc = window.fetch(that.url)\n            .then(response => response.text())\n            .then(function(str) {\n                return (new window.DOMParser()).parseFromString(str, \"text/xml\")\n            })\n            // .then(str => return (new window.DOMParser()).parseFromString(str, \"text/xml\"))\n            .then(function(ret) {\n                console.log(ret.activeElement);\n                let map = ret.activeElement;\n                that.width = map.getAttribute(\"width\");\n                that.height = map.getAttribute(\"height\");\n                that.tileWidth = map.getAttribute(\"tilewidth\");\n                that.tileHeight = map.getAttribute(\"tileheight\");\n                that.xmlDoc = ret;\n\n                for (let tileSet of map.getElementsByTagName('tileset')) {\n                    console.log(tileSet);\n                    let imageWidth = tileSet.getAttribute('width');\n                    let imageHeight = tileSet.getAttribute('height');\n                    let firstGid = tileSet.getAttribute(\"firstgid\");\n                    let tilesetName = tileSet.getAttribute(\"name\");\n                    let tilesetTileWidth = tileSet.getAttribute(\"tilewidth\");\n                    let tilesetTileHeight = tileSet.getAttribute(\"tileheight\");\n                    let tilesetImagePath = tileSet.getAttribute(\"source\");\n                    that.tileSets.push(new TileSet(firstGid, tilesetName, tilesetTileWidth, tilesetTileHeight, tilesetImagePath, imageWidth, imageHeight));\n                }\n\n                let xmlCounter = 0;\n            });\n            // .then(data => console.log(data));\n            // that.width = xmlDoc.attribute(\"width\");\n            // that.height = xmlDoc.attribute(\"height\");\n            // that.tileWidth = xmlDoc.attribute(\"tilewidth\");\n            // that.tileHeight = xmlDoc.attribute(\"tileheight\");\n        // console.log(xmlDoc);\n    }*/\n}\n\nexport { Map };\n","\"use strict\";\n// import { Game } from './Game.js';\nimport { funcs } from \"./funcs.js\";\n\nclass Player {\n  constructor(startX, startY) {\n    this.level = 1;\n    this.experience = 0;\n    this.nextLevel = 100;\n    this.damage = 5;\n    this.health = 100;\n    this.stamina = 100;\n    this.maxHealth = 100;\n    this.maxStamina = 100;\n    this.facing = \"\";\n    this.facingY = \"south\";\n    this.facingX = 1;\n    this.frame = 1;\n    this.startX = startX;\n    this.startY = startY;\n    this.keyPressed = {};\n    this.posX = startX;\n    this.posY = startY;\n    this.moving = false;\n    this.moveSpeed = 8;\n    this.calculatedMoveSpeed = 1;\n    this.offsetFrameY = 0;\n    this.offsetFrameX = 0;\n    this.animationFrame = 0;\n    this.animationFrames = [12, 7, 9, 9, 9, 5, 4, 7, 12, 7, 9, 9, 9, 5, 4, 7];\n    this.animationTimer = null;\n    this.height = 32;\n    this.width = 32;\n    this.attacking = false;\n    this.attackCooldown = 9;\n    this.attackCounter = 0;\n    this.attackTimer = 0;\n    this.attackCombo = 0;\n    this.jumping = false;\n    this.jumpCooldown = 9;\n    this.jumpCounter = 0;\n    this.jumpTimer = 0;\n    this.fps = 10;\n    this.hurtTimer = null;\n    this.hurt = false;\n    this.alive = true;\n    this.clickX = 0;\n    this.clickY = 0;\n    this.clickAction = \"move\";\n    this.clickTarget = null;\n    this.hoverAction = \"move\";\n    // this.startAnimation();\n  }\n\n  die() {\n    this.alive = false;\n    this.doAnimation(7, false);\n  }\n\n  mouseUp(e) {\n    // console.log(e);\n  }\n\n  mouseDown(e, worldXOffset, worldYOffset) {\n    let el = e.target;\n\n    if (el.getTagName == \"canvas\") {\n      this.clickX = e.clientX - el.offsetLeft;\n      this.clickY = e.clientY - el.offsetTop;\n      this.realClickX = e.clientX - el.offsetLeft - worldXOffset;\n      this.realClickY = e.clientY - el.offsetTop - worldYOffset;\n    }\n    this.clickAction = this.hoverAction;\n    this.clickTarget = this.hoverTarget;\n  }\n\n  doAnimation(yOffset, restart = true, duration = 999) {\n    let updateAnimationFrames = this.updateAnimationFrames.bind(this);\n    let getAnimationType = this.getAnimationType.bind(this);\n    let startAnimation = this.startAnimation.bind(this);\n    let stopAnimation = this.stopAnimation.bind(this);\n\n    stopAnimation();\n    // clearInterval(this.animationTimer);\n    if (duration === 999) {\n      duration = this.animationFrames[yOffset] * (1000 / this.fps);\n    }\n    console.log(duration);\n    this.offsetFrameY = 0;\n    if (this.facingX == 0) {\n      this.offsetFrameY += 8;\n    }\n    // this.getAnimationType();\n    this.offsetFrameY += yOffset;\n    this.offsetFrameX = 0;\n    let counter = 0;\n    this.animationTimer = setInterval(function() {\n      counter++;\n      console.log(counter);\n      updateAnimationFrames();\n    }, 1000 / this.fps);\n\n    setTimeout(function() {\n      stopAnimation();\n      if (restart) {\n        startAnimation();\n      }\n    }, duration);\n  }\n\n  stopAnimation() {\n    clearInterval(this.animationTimer);\n  }\n\n  getHurt(damage) {\n    if (!this.hurt) {\n      let doAnimation = this.doAnimation.bind(this);\n      // let setNotHurting = this.setNotHurting.bind(this);\n      let setNotHurt = this.setNotHurt.bind(this);\n\n      clearInterval(this.attackTimer);\n      this.attackCounter = 0;\n      this.attacking = false;\n      this.hurt = true;\n      // this.hurting = true;\n      this.health -= damage;\n      if (this.health <= 0) {\n        this.die();\n        console.log(\"Player died\");\n      } else {\n        this.offsetFrameX = 0;\n        doAnimation(6);\n        this.hurtTimer = setTimeout(function() {\n          // setNotHurting();\n          setNotHurt();\n        }, 400);\n      }\n      // this.hurt = hurt;\n    }\n  }\n\n  pressKey(key, pressed) {\n    this.keyPressed[key] = pressed;\n  }\n\n  getxp(xp) {\n    this.experience += xp;\n    if (this.experience >= this.nextLevel) {\n      this.level += 1;\n      this.nextLevel = this.nextLevel + this.nextLevel * 1.5;\n      this.experience = 0;\n    }\n  }\n\n  setNotHurt() {\n    this.hurt = false;\n  }\n\n  setNotHurting() {\n    this.hurting = false;\n  }\n\n  attack() {\n    if (this.clickTarget.alive) {\n      if (this.attackCombo >= 2) {\n        this.attackCombo = 0;\n      } else {\n        this.attackCombo++;\n      }\n      if (!this.attacking) {\n        let attackTimer = this.attackTimer;\n        let attacking = this.attacking;\n        let offsetFrameX = this.offsetFrameX;\n        let attackCounter = this.attackCounter;\n        let attackCooldown = this.attackCooldown;\n        let damage = this.damage;\n        let clickTarget = this.clickTarget;\n        let setNotAttacking = this.setNotAttacking.bind(this);\n\n        this.stamina -= 10;\n        this.offsetFrameX = 0;\n        this.attacking = true;\n\n        this.doAnimation(2 + this.attackCombo);\n        attackCounter = attackCooldown;\n        this.attackTimer = setInterval(function() {\n          if (attackCounter == attackCooldown - 2) {\n            clickTarget.getHurt(damage);\n          }\n          if (attackCounter == 0) {\n            clearInterval(attackTimer);\n            // attacking = false;\n            setNotAttacking();\n            console.log(\"player not attacking\");\n            offsetFrameX = 0;\n          }\n          attackCounter--;\n        }, 1000 / this.fps);\n      }\n    }\n  }\n\n  setNotAttacking() {\n    this.attacking = false;\n  }\n\n  jump() {\n    this.offsetFrameX = 0;\n    if (!this.jumping && this.jumpCounter <= 0) {\n      this.jumping = true;\n      this.jumpTimer = this.jumpCooldown;\n      this.jumpTimer = setInterval(function() {\n        this.jumpCounter--;\n        if (this.jumpCounter == 0) {\n          clearInterval(this.jumpTimer);\n          this.jumping = false;\n          this.offsetFrameX = 0;\n        }\n      }, 1000 / this.fps);\n    }\n  }\n\n  getXTarget() {\n    let xTarget = this.realClickX;\n\n    if (this.clickTarget !== undefined && this.clickTarget !== null) {\n      xTarget = this.clickTarget.getXCenterPos() - this.clickTarget.getWidth();\n    }\n    return xTarget;\n  }\n\n  getYTarget() {\n    let yTarget = this.realClickY;\n\n    if (this.clickTarget !== undefined && this.clickTarget !== null) {\n      yTarget = this.clickTarget.getYCenterPos() - this.clickTarget.getHeight();\n    }\n    return yTarget;\n  }\n\n  checkObjectsCollision(a1, a2, map) {\n    let objL = map.plane.objects;\n    let ts = map.tileSets[0].tiles;\n\n    // console.log(map);\n    for (let x = map.startX; x < map.endX; x++) {\n      for (let y = map.startY; y < map.endY; y++) {\n        if (objL[x][y]) {\n          let tileType = objL[x][y].getType();\n\n          if (tileType != 0) {\n            let t = {\n              x: objL[x][y].xOffset + map.worldXOffset,\n              y: objL[x][y].yOffset + map.worldYOffset,\n              width: objL[x][y].width,\n              height: objL[x][y].height\n            };\n\n            if (funcs.isCollide(a1, t)) {\n              // console.log(objL[x][y])\n              // console.log('colliding;')\n              this.isCollidingX = true;\n            }\n\n            if (funcs.isCollide(a2, t)) {\n              // console.log('colliding;')\n              this.isCollidingY = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  move2(worldOffset, enemies, map) {\n    if (this.alive) {\n      let targetX = this.getXTarget();\n      let targetY = this.getYTarget();\n      let dx = targetX - this.posX;\n      let dy = targetY - this.posY;\n      let hMovement = dx > 0 ? 1 : dx < 0 ? -1 : 0;\n      let vMovement = dy > 0 ? 1 : dy < 0 ? -1 : 0;\n      let distance = Math.round(Math.sqrt(dx * dx + dy * dy));\n\n      distance = this.clickTarget\n        ? distance - this.clickTarget.width * 2 + 5\n        : distance;\n      // console.log(this.attacking, this.hurt);\n      if (!this.attacking && !this.hurt) {\n        // console.log(distance, this.moveSpeed);\n        if (targetX && targetY && distance - this.moveSpeed > this.moveSpeed) {\n          let xSpeed = Math.round((dx / distance) * this.moveSpeed * hMovement);\n          let ySpeed = Math.round((dy / distance) * this.moveSpeed * vMovement);\n\n          let a1 = {\n            x: this.playerXPos + this.moveSpeed * hMovement,\n            y: this.playerYPos,\n            width: this.width * 1.5 - 12,\n            height: this.height * 1.5 - 6\n          };\n          let a2 = {\n            x: this.playerXPos,\n            y: this.playerYPos + this.moveSpeed * vMovement,\n            width: this.width * 1.5 - 12,\n            height: this.height * 1.5 - 6\n          };\n\n          this.isCollidingX = false;\n          this.isCollidingY = false;\n\n          for (let enemy of enemies) {\n            let b = {\n              x: enemy.realXPos,\n              y: enemy.realYPos,\n              width: enemy.width * 2,\n              height: enemy.height * 2\n            };\n\n            if (funcs.isCollide(a1, b)) {\n              this.isCollidingX = true;\n            }\n\n            if (funcs.isCollide(a2, b)) {\n              this.isCollidingY = true;\n            }\n          }\n\n          // console.log(objL, ts)\n\n          this.checkObjectsCollision(a1, a2, map);\n\n          if (this.isCollidingX && this.isCollidingY) {\n            this.stopMoving();\n          } else {\n            if (!this.isCollidingX) {\n              this.posX += xSpeed * hMovement;\n            } else if (ySpeed <= 0.5) {\n              this.stopMoving();\n              // this.posY += this.moveSpeed * vMovement;\n              // this.posX += 0.1 * -hMovement;\n            }\n            if (!this.isCollidingY) {\n              this.posY += ySpeed * vMovement;\n            } else if (xSpeed <= 0.5) {\n              this.stopMoving();\n              // this.posX += this.moveSpeed * hMovement;\n              // this.posY += 0.1 * -vMovement;\n            }\n          }\n\n          if (!this.moving) {\n            this.offsetFrameX = 0;\n          }\n\n          if (dx > 0) {\n            this.facingX = 1;\n          } else if (dx < 0) {\n            this.facingX = 0;\n          }\n\n          this.moving = true;\n        } else {\n          if (this.clickTarget !== null && this.clickTarget !== undefined) {\n            this.attack();\n          }\n          this.stopMoving();\n        }\n      }\n    }\n  }\n\n  move(worldOffset) {\n    if (this.alive) {\n      let hMovement = this.checkPressed(\"d\") - this.checkPressed(\"a\");\n      let vMovement = this.checkPressed(\"s\") - this.checkPressed(\"w\");\n      let attacked = this.checkPressed(\"e\") == 1;\n      let jumped = this.checkPressed(\" \") == 1;\n      let running = this.checkPressed(\"Shift\") == 1;\n      // let moved = this.checkPressed('d') || this.checkPressed('a') || this.checkPressed('s') || this.checkPressed('w');\n\n      // if (moved && !this.moving || !moved && this.moving) {\n      //     this.attacking = false;\n      // }\n      // console.log(this.keyPressed);\n      if (!this.attacking && !this.hurt) {\n        if (hMovement != 0 && vMovement != 0) {\n          if (running) {\n            this.moveSpeed = 20;\n          } else {\n            this.moveSpeed = 8;\n          }\n          let xySpeed = Math.round(\n            Math.sqrt((this.moveSpeed * this.moveSpeed) / 2)\n          );\n          let steph = xySpeed * hMovement;\n          let stepv = xySpeed * vMovement;\n\n          if (!this.moving) {\n            this.offsetFrameX = 0;\n          }\n\n          this.moving = true;\n          if (\n            this.posX + steph >= 0 &&\n            this.posX + steph + this.width * 2 <= worldOffset.w\n          ) {\n            this.posX += steph;\n            // this.posX += steph;\n          }\n          if (\n            this.posY + stepv >= 0 &&\n            this.posY + stepv + this.height * 2 < worldOffset.h\n          ) {\n            this.posY += stepv;\n          }\n          // this.posX += steph;\n          // this.posY += stepv;\n\n          // this.posY += stepv;\n        } else if (hMovement != 0 || vMovement != 0) {\n          if (!this.moving) {\n            this.offsetFrameX = 0;\n          }\n          this.moving = true;\n          var steph = hMovement * this.moveSpeed;\n          var stepv = vMovement * this.moveSpeed;\n\n          if (\n            this.posX + steph >= 0 &&\n            this.posX + steph + this.width * 2 <= worldOffset.w\n          ) {\n            this.posX += steph;\n          }\n\n          if (\n            this.posY + stepv >= 0 &&\n            this.posY + stepv + this.height * 2 < worldOffset.h\n          ) {\n            this.posY += stepv;\n          }\n          // this.posX += hMovement * this.moveSpeed;\n          // this.posY += vMovement * this.moveSpeed;\n        }\n\n        if (vMovement == 0 && hMovement == 0) {\n          if (this.moving) {\n            this.offsetFrameX = 0;\n          }\n          this.moving = false;\n        }\n\n        if (jumped && !this.jumping) {\n          this.jump();\n        }\n\n        this.facing = this.returnDirection();\n      }\n\n      if (attacked && !this.attacking) {\n        this.attack();\n      }\n    }\n  }\n\n  stopMoving() {\n    this.clickTarget = null;\n    this.realClickY = null;\n    this.realClickX = null;\n    this.moving = false;\n  }\n\n  startData() {\n    let updateData = this.updateData.bind(this);\n\n    this.updateTimer = setInterval(function() {\n      updateData();\n    }, 1000 / this.fps);\n  }\n\n  startAnimation() {\n    let getAnimationType = this.getAnimationType.bind(this);\n    let updateData = this.updateData.bind(this);\n    let updateAnimationFrames = this.updateAnimationFrames.bind(this);\n    clearInterval(this.animationTimer);\n\n    this.animationTimer = setInterval(function() {\n      getAnimationType();\n      updateData();\n      updateAnimationFrames();\n    }, 1000 / this.fps);\n    this.started = true;\n  }\n\n  updateData() {\n    if (!this.moving) {\n      if (this.stamina != this.maxStamina) {\n        this.stamina = this.stamina + 0.5;\n      }\n    }\n\n    if (this.stamina < 0) {\n      this.stamina = 0;\n    }\n    if (this.health < 0) {\n      this.health = 0;\n    }\n  }\n\n  updateAnimationFrames() {\n    let outOfBounds =\n      this.offsetFrameX >= this.animationFrames[this.offsetFrameY];\n\n    // if (this.attacking && outOfBounds) {\n    //     this.attacking = false;\n    // }\n\n    // if (this.jumping && outOfBounds) {\n    //     this.jumping = false;\n    // }\n\n    // if (this.hurting && outOfBounds) {\n    //     this.hurting = false;\n    // }\n\n    if (this.animationFrames[this.offsetFrameY] === undefined || outOfBounds) {\n      this.animationFrame = 0;\n      this.offsetFrameX = 0;\n    } else {\n      this.offsetFrameX += 1;\n    }\n  }\n\n  returnDirection() {\n    if (this.moving) {\n      this.action = \"running\";\n      // this.facingX = '';\n      if (this.checkPressed(\"d\")) {\n        this.facingX = 1;\n      } else if (this.checkPressed(\"a\")) {\n        this.facingX = 0;\n      }\n\n      this.facingY = \"\";\n    } else {\n      this.action = \"standing\";\n    }\n\n    return this.action + this.facingY + this.facingX;\n  }\n\n  getAnimationType() {\n    this.offsetFrameY = 0;\n    if (this.facingX == 0) {\n      this.offsetFrameY += 8;\n    }\n\n    if (!this.alive) {\n      this.offsetFrameY += 7;\n    } /*else if (this.jumping) {\n            this.offsetFrameY += 5;\n        } else if (this.attacking) {\n            this.offsetFrameY += 2 + this.attackCombo;\n        } else if (this.hurting) {\n            this.offsetFrameY += 6;\n        } */ else if (\n      this.moving\n    ) {\n      this.offsetFrameY += 1;\n    }\n  }\n\n  checkPressed(key) {\n    return this.keyPressed[key] ? 1 : 0;\n  }\n}\n\nexport { Player };\n","\"use strict\";\n\nimport { Enemy } from \"./Enemy.js\";\n// import { TileSet } from './TileSet.js';\n// import { funcs } from './funcs.js';\n\nclass Slime extends Enemy {\n  constructor(x, y, name, maxHealth, damage, speed, expGive) {\n    super(x, y, name, maxHealth, damage, speed, expGive);\n    this.image = \"slime_red.png\";\n    this.animationFrames = [3];\n    this.width = 16;\n    this.height = 16;\n    this.moveSpeed = 3;\n    this.attackCooldown = 3000;\n  }\n\n  getImage() {\n    return this.image;\n  }\n\n  getWidth() {\n    return this.width;\n  }\n\n  getHeight() {\n    return this.height;\n  }\n\n  getXPos() {\n    return this.xPos;\n  }\n\n  getYPos() {\n    return this.yPos;\n  }\n\n  startAnimation() {\n    let that = this;\n\n    if (!that.started) {\n      that.animationTimer = setInterval(function() {\n        that.updateAnimationFrames();\n      }, 1000 / 10);\n      that.started = true;\n    }\n  }\n\n  die() {\n    this.alive = false;\n  }\n\n  getHurt(damage) {\n    let that = this;\n\n    if (!that.hurt) {\n      console.log(`${that.name} was damaged ${damage} points!`);\n      that.hurt = true;\n      that.health -= damage;\n      that.hurtTimer = setTimeout(function() {\n        if (that.health <= 0) {\n          that.die();\n          console.log(`${that.name} died!`);\n        }\n        that.hurt = false;\n        console.log(\"not hurt\");\n      }, 1000);\n    }\n  }\n\n  updateAnimationFrames() {\n    let that = this;\n    let outOfBounds =\n      that.offsetFrameX >= that.animationFrames[that.offsetFrameY];\n\n    // if (that.attacking && outOfBounds) {\n    //     that.attacking = false;\n    // }\n\n    if (that.hurt && that.offsetFrameX % 2 != 0) {\n      that.offsetFrameY = 1;\n    } else {\n      that.offsetFrameY = 0;\n    }\n\n    if (that.animationFrames[that.offsetFrameY] === undefined || outOfBounds) {\n      that.animationFrame = 0;\n      that.offsetFrameX = 0;\n    } else {\n      that.offsetFrameX += 1;\n    }\n  }\n}\n\nexport { Slime };\n","\"use strict\";\n\n// import { Player } from './Player.js';\n// import { TileSet } from './TileSet.js';\n// import { funcs } from './funcs.js';\n\nclass Tile {\n  constructor(id, xOffset, yOffset, width, height, type) {\n    this.id = id;\n    this.xOffset = xOffset;\n    this.yOffset = yOffset;\n    this.width = width;\n    this.height = height;\n    this.type = type;\n    // var tileAmountWidth = Math.floor(width / tileWidth);\n    // this.lastgid = tileAmountWidth * Math.floor(height / tileHeight) + firstgid - 1;\n  }\n\n  getId() {\n    return this.id;\n  }\n\n  getXOffset() {\n    return this.xOffset;\n  }\n\n  getYOffset() {\n    return this.yOffset;\n  }\n\n  getWidth() {\n    return this.width;\n  }\n\n  getHeight() {\n    return this.height;\n  }\n\n  getType() {\n    return this.type;\n  }\n}\n\nexport { Tile };\n","'use strict';\n\n// import { Player } from './Player.js';\n// import { TileSet } from './TileSet.js';\nimport { Tile } from './Tile.js';\n\nclass TileSet {\n  constructor(firstgid, tileWidth, tileHeight, source, width, height) {\n    var tileAmountWidth = Math.floor(width / tileWidth);\n\n    this.firstgid = firstgid;\n    this.tileWidth = tileWidth;\n    this.tileHeight = tileHeight;\n    this.source = source;\n    this.width = width;\n    this.height = height;\n    this.lastgid =\n      tileAmountWidth * Math.floor(height / tileHeight) + firstgid - 1;\n    this.tiles = [];\n  }\n\n  async loadTileSetImage() {\n    let mapimage = await window.fetch(\n      'assets/img/map/overworld1.tsx' /* + this.source*/\n    );\n    let text = await mapimage.text();\n    let xmlDoc = new window.DOMParser().parseFromString(text, 'text/xml');\n    let tileCounter = 1;\n\n    console.log(xmlDoc);\n    console.log(xmlDoc.getElementsByTagName('image'));\n    this.mapImage = xmlDoc.getElementsByTagName('image')[0];\n    const tileset = xmlDoc.getElementsByTagName('tileset')[0];\n\n    this.columns = tileset.getAttribute('columns');\n    this.tilecount = tileset.getAttribute('tilecount');\n    this.tilewidth = tileset.getAttribute('tilewidth');\n    this.tileheight = tileset.getAttribute('tileheight');\n    this.spacing = tileset.getAttribute('spacing');\n    this.rows = this.tilecount / this.columns;\n    console.log(this);\n\n    // console.log(this.tilewidth * 39);\n\n    for (let y = 0; y < this.rows; y++) {\n      // this.tiles[y] = [];\n      for (let x = 0; x < this.columns; x++) {\n        let yOffset = y * (parseInt(this.tileheight) + parseInt(this.spacing));\n        let xOffset = x * (parseInt(this.tilewidth) + parseInt(this.spacing));\n\n        this.tiles[tileCounter] = new Tile(\n          tileCounter + 1,\n          xOffset,\n          yOffset,\n          this.tilewidth,\n          this.tileheight,\n          null //this.layers[0].data[tileCounter]\n        );\n        tileCounter++;\n      }\n    }\n  }\n}\n\nexport { TileSet };\n","\"use strict\";\n\nlet funcs = {};\n\nfuncs.bind = function(el, action, method) {\n  let element = null;\n\n  if (typeof el == \"string\") {\n    element = document.getElementById(el);\n  } else {\n    element = el;\n  }\n  element.addEventListener(action, method);\n};\n\nString.prototype.toCamelCase = function() {\n  return this.valueOf()\n    .replace(/\\s(.)/g, function($1) {\n      return $1.toUpperCase();\n    })\n    .replace(/\\s/g, \"\")\n    .replace(/^(.)/, function($1) {\n      return $1.toLowerCase();\n    });\n};\n\nfuncs.isCollide = function(a, b) {\n  return !(\n    a.y + a.height < b.y ||\n    a.y > b.y + b.height ||\n    a.x + a.width < b.x ||\n    a.x > b.x + b.width\n  );\n};\n\nfuncs.clone = function(obj) {\n  if (null == obj || \"object\" != typeof obj) {\n    return obj;\n  }\n  var copy = new obj.constructor();\n\n  for (var attr in obj) {\n    if (obj.hasOwnProperty(attr)) {\n      copy[attr] = obj[attr];\n    }\n  }\n  return copy;\n};\n\n// funcs.prototype.binds = function(el, action, method) {\n//     let element = null;\n\n//     if (typeof el == 'string') {\n//         element = document.getElementById(el);\n//     }\n//     element.addEventListener(action, method);\n// };\n\nexport { funcs };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\"use strict\";\n\nimport { Game } from \"./Game.js\";\nimport { Player } from \"./Player.js\";\nimport { Map } from \"./Map.js\";\n\nlet game = new Game(800, 600);\nlet map = new Map(\"assets/img/map/overworld1.json\");\n\nmap.loadMap().then(function() {\n  console.log(\"map loaded\");\n  game.map = map;\n\n  let initGame = game.init.bind(game);\n\n  initGame();\n  // game.init();\n  window.addEventListener(\"keyup\", function(e) {\n    game.player.pressKey(e.key, false);\n  });\n  window.addEventListener(\"keydown\", function(e) {\n    game.player.pressKey(e.key, true);\n  });\n  // window.addEventListener('mousedown', function(e) { game.player.mouseDown(e, true); });\n  // window.addEventListener('mouseup', function(e) { game.player.mouseUp(e, true); });\n  //     game.init();\n  //     window.addEventListener('keyup', function(e) { game.player.pressKey(e.key, false); });\n  //     window.addEventListener('keydown', function(e) { game.player.pressKey(e.key, true); });\n  //     console.log(map.xmlDoc);\n});\n\n/*app.keyPressed[e.key] = false;*/\n/*app.keyPressed[e.key] = true;*/\n\n// var xmlDoc = window.fetch(\"assets/img/map/map.xml\")\n//     .then(response => response.text())\n//     .then(str => (new window.DOMParser()).parseFromString(str, \"text/xml\"))\n//     .then(data => data);\n\n// console.log(xmlDoc);\n// game.start();\n"],"names":[],"sourceRoot":""}